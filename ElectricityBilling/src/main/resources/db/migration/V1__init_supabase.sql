-- Database Schema Design for Electricity Billing System
-- Target: PostgreSQL (Supabase)

-- Enable UUID extension if needed
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ==========================================
-- 1. Sequences for ID Generation
-- ==========================================

-- Sequence for Meter Numbers (e.g., MTR-2024-00001)
CREATE SEQUENCE IF NOT EXISTS meter_no_seq START 1;

-- ==========================================
-- 2. Tables
-- ==========================================

-- Users Table
CREATE TABLE IF NOT EXISTS users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL,
    active BOOLEAN DEFAULT TRUE
);

-- Tariffs Table
CREATE TABLE IF NOT EXISTS tariffs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    slab_start_kwh INT NOT NULL,
    slab_end_kwh INT, -- Null means infinity
    rate_per_kwh DOUBLE PRECISION NOT NULL,
    fixed_charge DOUBLE PRECISION DEFAULT 0,
    effective_from DATE,
    effective_to DATE
);

-- Customers Table
CREATE TABLE IF NOT EXISTS customers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(120) NOT NULL,
    email VARCHAR(120) UNIQUE,
    phone VARCHAR(20) UNIQUE,
    address VARCHAR(1000),
    meter_no VARCHAR(40) UNIQUE NOT NULL, -- Will be auto-generated
    user_id BIGINT REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Readings Table
CREATE TABLE IF NOT EXISTS readings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id BIGINT NOT NULL REFERENCES customers(id),
    previous_reading_kwh INT NOT NULL,
    current_reading_kwh INT NOT NULL,
    reading_date DATE NOT NULL,
    period_start DATE,
    period_end DATE,
    photo_url VARCHAR(255),
    CONSTRAINT check_reading_validity CHECK (current_reading_kwh >= previous_reading_kwh)
);

-- Bills Table
CREATE TABLE IF NOT EXISTS bills (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bill_no VARCHAR(40) UNIQUE NOT NULL,
    customer_id BIGINT NOT NULL REFERENCES customers(id),
    reading_id BIGINT NOT NULL REFERENCES readings(id),
    bill_date DATE NOT NULL,
    units INT NOT NULL,
    energy_charge DOUBLE PRECISION NOT NULL,
    fixed_charge DOUBLE PRECISION NOT NULL,
    taxes DOUBLE PRECISION NOT NULL,
    adjustments DOUBLE PRECISION DEFAULT 0,
    total DOUBLE PRECISION NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'DUE' -- DUE, PAID, OVERDUE
);

-- Payments Table
CREATE TABLE IF NOT EXISTS payments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bill_id BIGINT NOT NULL REFERENCES bills(id),
    amount DOUBLE PRECISION NOT NULL,
    payment_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    payment_mode VARCHAR(50),
    transaction_ref VARCHAR(100)
);

-- Audit Log Table (New Feature)
CREATE TABLE IF NOT EXISTS audit_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name VARCHAR(50) NOT NULL,
    record_id BIGINT,
    action VARCHAR(20) NOT NULL, -- INSERT, UPDATE, DELETE
    changed_by VARCHAR(50), -- Username if available
    change_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    old_values TEXT,
    new_values TEXT
);

-- ==========================================
-- 3. Functions & Triggers
-- ==========================================

-- Function to Auto-Generate Meter Number
CREATE OR REPLACE FUNCTION generate_meter_no()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.meter_no IS NULL OR NEW.meter_no = '' THEN
        -- Format: MTR-YYYY-XXXXX
        NEW.meter_no := 'MTR-' || TO_CHAR(CURRENT_DATE, 'YYYY') || '-' || LPAD(nextval('meter_no_seq')::TEXT, 5, '0');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for Meter Number
DROP TRIGGER IF EXISTS trg_generate_meter_no ON customers;
CREATE TRIGGER trg_generate_meter_no
BEFORE INSERT ON customers
FOR EACH ROW
EXECUTE FUNCTION generate_meter_no();

-- Function to Audit Tariff Changes
CREATE OR REPLACE FUNCTION audit_tariff_changes()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_logs (table_name, record_id, action, old_values, new_values)
    VALUES (
        'tariffs',
        COALESCE(NEW.id, OLD.id),
        TG_OP,
        row_to_json(OLD)::TEXT,
        row_to_json(NEW)::TEXT
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for Tariff Audit
DROP TRIGGER IF EXISTS trg_audit_tariffs ON tariffs;
CREATE TRIGGER trg_audit_tariffs
AFTER INSERT OR UPDATE OR DELETE ON tariffs
FOR EACH ROW
EXECUTE FUNCTION audit_tariff_changes();

-- ==========================================
-- 4. Views
-- ==========================================

-- Customer Summary View
CREATE OR REPLACE VIEW v_customer_summary AS
SELECT 
    c.id,
    c.name,
    c.meter_no,
    COUNT(b.id) as total_bills,
    SUM(CASE WHEN b.status = 'DUE' THEN b.total ELSE 0 END) as total_due,
    MAX(b.bill_date) as last_bill_date
FROM customers c
LEFT JOIN bills b ON c.id = b.customer_id
GROUP BY c.id, c.name, c.meter_no;
